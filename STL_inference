import random
from cmath import exp, inf
from random import sample

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import torch

import stlcg
import GPyOptPars
from GPyOptPars import GP_opt


###################    Import Data    ##############################
x1_reg = pd.read_excel(r'x1_reg.xlsx', header=None)
x2_reg = pd.read_excel(r'x2_reg.xlsx', header=None)
x1_anom = pd.read_excel(r'x1_anom.xlsx', header=None)
x2_anom = pd.read_excel(r'x2_anom.xlsx', header=None)

rng_x1_reg = (min(x1_reg.min()), max(x1_reg.max()))
rng_x2_reg = (min(x2_reg.min()), max(x2_reg.max()))
rng_x1_anom = (min(x1_anom.min()), max(x1_anom.max()))
rng_x2_anom = (min(x2_anom.min()), max(x2_anom.max()))


rng = [rng_x1_reg, rng_x2_reg, rng_x1_anom, rng_x2_anom, len(x1_reg)]

x1_reg_exp = []
x2_reg_exp = []
x1_anom_exp = []
x2_anom_exp = []

for i in range(len(x1_reg.columns)):
    x1 = torch.tensor(x1_reg.iloc[:, i])
    x1 = x1.reshape(x1.shape[0], 1, 1)
    x_exp = stlcg.Expression('x1', x1)
    x1_reg_exp.append(x_exp)

    x2 = torch.tensor(x2_reg.iloc[:, i])
    x2 = x2.reshape(x2.shape[0], 1, 1)
    x_exp = stlcg.Expression('x2', x2)
    x2_reg_exp.append(x_exp)

    x1_ano = torch.tensor(x1_anom.iloc[:, i])
    x1_ano = x1_ano.reshape(x1_anom.shape[0], 1, 1)
    x_exp = stlcg.Expression('x1', x1_ano)
    x1_anom_exp.append(x_exp)

    x2_ano = torch.tensor(x2_anom.iloc[:, i])
    x2_ano = x2_ano.reshape(x2_ano.shape[0], 1, 1)
    x_exp = stlcg.Expression('x2', x2_ano)
    x2_anom_exp.append(x_exp)


###########  Random initialization of primary population and GP_opt to update parameters  ##########

pop_df = pd.DataFrame()
par = []
sig = []


population = {}
sig.append('x')
X = GP_opt('lessthan', sig[-1], input1=x1_reg_exp, input2=x2_reg_exp,
           input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([X[0]])
population['phi_1'] = x1_reg_exp[0] < X[0]
sig.append('x')
X = GP_opt('greaterthan', sig[-1], input1=x1_reg_exp, input2=x2_reg_exp,
           input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([X[0]])
population['phi_2'] = x1_reg_exp[0] > X[0]
sig.append('y')
X = GP_opt('lessthan', sig[-1], input1=x1_reg_exp, input2=x2_reg_exp,
           input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([X[0]])
population['phi_3'] = x2_reg_exp[0] < X[0]
sig.append('y')
X = GP_opt('greaterthan', sig[-1], input1=x1_reg_exp, input2=x2_reg_exp,
           input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([X[0]])
population['phi_4'] = x2_reg_exp[0] > X[0]

sig.append('x')
X = GP_opt('always', sig[-1], population['phi_1'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_5'] = stlcg.Always(
    population['phi_1'], interval=[int(X[0]), int(X[1])])
sig.append('x')
X = GP_opt('always', sig[-1], population['phi_2'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_6'] = stlcg.Always(
    population['phi_2'], interval=[int(X[0]), int(X[1])])
sig.append('y')
X = GP_opt('always', sig[-1], population['phi_3'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_7'] = stlcg.Always(
    population['phi_3'], interval=[int(X[0]), int(X[1])])
sig.append('y')
X = GP_opt('always', sig[-1], population['phi_4'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_8'] = stlcg.Always(
    population['phi_4'], interval=[int(X[0]), int(X[1])])

sig.append('x')
X = GP_opt('eventually', sig[-1], population['phi_1'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_9'] = stlcg.Eventually(
    population['phi_1'], interval=[int(X[0]), int(X[1])])
sig.append('x')
X = GP_opt('eventually', sig[-1], population['phi_2'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_10'] = stlcg.Eventually(
    population['phi_2'], interval=[int(X[0]), int(X[1])])
sig.append('y')
X = GP_opt('eventually', sig[-1], population['phi_3'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_11'] = stlcg.Eventually(
    population['phi_3'], interval=[int(X[0]), int(X[1])])
sig.append('y')
X = GP_opt('eventually', sig[-1], population['phi_4'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_12'] = stlcg.Eventually(
    population['phi_4'], interval=[int(X[0]), int(X[1])])

sig.append('x')
X = GP_opt('always', sig[-1], population['phi_9'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_13'] = stlcg.Always(
    population['phi_9'], interval=[int(X[0]), int(X[1])])
sig.append('x')
X = GP_opt('always', sig[-1], population['phi_10'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_14'] = stlcg.Always(
    population['phi_10'], interval=[int(X[0]), int(X[1])])
sig.append('y')
X = GP_opt('always', sig[-1], population['phi_11'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_15'] = stlcg.Always(
    population['phi_11'], interval=[int(X[0]), int(X[1])])
sig.append('y')
X = GP_opt('always', sig[-1], population['phi_12'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_16'] = stlcg.Always(
    population['phi_12'], interval=[int(X[0]), int(X[1])])

sig.append('x')
X = GP_opt('eventually', sig[-1], population['phi_5'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_17'] = stlcg.Eventually(
    population['phi_5'], interval=[int(X[0]), int(X[1])])
sig.append('x')
X = GP_opt('eventually', sig[-1], population['phi_6'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_18'] = stlcg.Eventually(
    population['phi_6'], interval=[int(X[0]), int(X[1])])
sig.append('y')
X = GP_opt('eventually', sig[-1], population['phi_7'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_19'] = stlcg.Eventually(
    population['phi_7'], interval=[int(X[0]), int(X[1])])
sig.append('y')
X = GP_opt('eventually', sig[-1], population['phi_8'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
par.append([int(X[0]), int(X[1])])
population['phi_20'] = stlcg.Eventually(
    population['phi_8'], interval=[int(X[0]), int(X[1])])


pop_df['Name'] = population.keys()
pop_df['Formula'] = population.values()
pop_df['Subformula'] = [x1_reg_exp[0], x1_reg_exp[0], x2_reg_exp[0], x2_reg_exp[0], population['phi_1'], population['phi_2'], population['phi_3'], population['phi_4'], population['phi_1'], population['phi_2'],
                        population['phi_3'], population['phi_4'], population['phi_5'], population['phi_6'], population['phi_7'], population['phi_8'], population['phi_9'], population['phi_10'], population['phi_11'], population['phi_12']]
pop_df['Signal'] = sig
pop_df['Parameters']= par
print(pop_df.head(20))

######################### random initialization of non-primary formulae + GP_opt  #######################
pop_ext = {}
for i in range(11, 51):
    rand = random.randint(2, 3)
    num = random.sample(range(0, 20), 2)

    subformula = [pop_df.iloc[num[0]]['Formula'],
                  pop_df.iloc[num[1]]['Formula']]
    
    if rand == 1:
        while pop_df.iloc[num[0]]['Signal'] == pop_df.iloc[num[1]]['Signal']:
            num = random.sample(range(0, len(pop_df)+1), 2)
            subformula = [pop_df.iloc[num[0]]['Formula'], pop_df.iloc[num[1]]['Formula']]
            
        X = GP_opt('until',  [pop_df.iloc[num[0]]['Signal'], pop_df.iloc[num[1]]['Signal']], subformula[0], subformula[1], input1=x1_reg_exp,
                   input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        pop_ext['phi_' +
                str(i)] = stlcg.Until(subformula[0], subformula[1], interval=[int(X[1]), int(X[1])])

        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]], 'Signal': [pop_df.iloc[num[0]]['Signal'], pop_df.iloc[num[1]]['Signal']]}, ignore_index=True)
    elif rand == 2:
        pop_ext['phi_' +
                str(i)] = stlcg.And(subformula[0], subformula[1])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]], 'Signal': [pop_df.iloc[num[0]]['Signal'], pop_df.iloc[num[1]]['Signal']]}, ignore_index=True)
    elif rand == 3:
        pop_ext['phi_' +
                str(i)] = stlcg.Or(subformula[0], subformula[1])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]], 'Signal': [pop_df.iloc[num[0]]['Signal'], pop_df.iloc[num[1]]['Signal']]}, ignore_index=True)
    elif rand == 4:
        pop_ext['phi_' +
                str(i)] = stlcg.Negation(subformula[0])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0]], 'Signal': [pop_df.iloc[num[0]]['Signal']]}, ignore_index=True)
population = {**population, **pop_ext}

print('Length of DF ---', len(pop_df))


##############################     parameters for formula           ##################
import copy

def fix_IP(signal,l):  
    if isinstance(signal, str):
        signal = [signal]
    
    copy_sig = copy.deepcopy(signal)      
    copy_sig = tuple(x1_reg_exp[l] if not isinstance(j,list) and j == 'x' else x2_reg_exp[l] if not isinstance(j,list) and j == 'y'
                else(tuple(x1_reg_exp[l] if not isinstance(k,list) and k == 'x' else x2_reg_exp[l] if not isinstance(k,list) and k == 'y'
                    else (tuple(tuple(tuple(tuple(tuple(tuple(tuple(tuple(g) if not isinstance(g,list) else x1_reg_exp[l] if g == 'x' else x2_reg_exp[l] for g in n)
                        if isinstance(n,list) else x1_reg_exp[l] if n == 'x' else x2_reg_exp[l] for n in v)
                            if isinstance(v,list) else x1_reg_exp[l] if v == 'x' else x2_reg_exp[l] for v in w)
                                if isinstance(w,list)  else x1_reg_exp[l] if w == 'x' else x2_reg_exp[l] for w in s)
                                    if isinstance(s,list)  else x1_reg_exp[l] if s == 'x' else x2_reg_exp[l] for s in z)
                                        if isinstance(z,list)  else x1_reg_exp[l] if z == 'x' else x2_reg_exp[l] for z in i)
                                            if isinstance(i,list)  else x1_reg_exp[l] if i == 'x' else x2_reg_exp[l] for i in k)) for k in j)) for j in copy_sig)
    return copy_sig

def compute_rob(formula, signal, pars):
    rob_all = np.empty(0)
    print('fromula: ', formula, 'signal: ', signal)
    for l in range(len(x1_reg_exp)):      
        IP = fix_IP(signal,l)        
        
        print('Tuple signal: ', IP)
        
        try:
            if isinstance(formula, stlcg.Always):
                rob = float(min(formula.robustness(IP[0])[pars[0]:pars[1]]))
            elif isinstance(formula, stlcg.Eventually):
                rob = float(max(formula.robustness(IP[0])[pars[0]:pars[1]]))
            else:
                rob = float(min(formula.robustness(IP[0])))
        except:
            if isinstance(formula, stlcg.Always):
                rob = float(min(formula.robustness(IP)[pars[0]:pars[1]]))
            elif isinstance(formula, stlcg.Eventually):
                rob = float(max(formula.robustness(IP)[pars[0]:pars[1]]))
            else:
                rob = float(min(formula.robustness(IP)))
                
        rob_all = np.append(rob_all, rob)
    
    return np.average(rob_all)


def formula_size(formula):
    string = str(formula)
    ops = '<>♢◻∧∨¬U'
    count = 0
    for i in string:
        if i in ops:
            count += 1
    return count


def fitness_func(robustness, size):
    if size < 3:
        Fitness_score = robustness
    else:
        # decrease robustness by (size-2)X10 % for sizes greater than 2
        Fitness_score = robustness*(1-(size-2))*0.1
    return Fitness_score
    
 #####################      Rearrange  population with descending order of fitness  ############


def rank(dataframe):
    dataframe['Rank'] = dataframe['Fitness'].rank(ascending=0)
    dataframe = dataframe.set_index('Rank')
    dataframe = dataframe.sort_index()
    dataframe.reset_index(inplace=True)
    dataframe.drop(columns=['Rank'])
    return dataframe

###################      Compute robustness, size, and fitness       ###########################


pop_rob = []
pop_size = []
pop_fit = []
for i in range(len(pop_df)):
    formula = pop_df.iloc[i]['Formula']
    subformula = pop_df.iloc[i]['Subformula']
    signal = pop_df.iloc[i]['Signal']
    pars = pop_df.iloc[i]['Parameters']

    pop_rob.append(compute_rob(formula, signal, pars))
    print('Average robustness(reg dataset): ', pop_rob[-1])

    pop_size.append(formula_size(formula))
    print('Size: ', formula_size(formula))

    pop_fit.append(fitness_func(pop_rob[-1], pop_size[-1]))
    print('Fitness Score: ', pop_fit[-1])


####################          Update dataframe        ##########################

pop_df['Robustness'] = pop_rob
pop_df['Size'] = pop_size
pop_df['Fitness'] = pop_fit

####################       New generation parents (Top 25)   ####################
pop_df_ranked = rank(pop_df)
pop_df_new = pop_df.head(25)
print(pop_df_new.head(10))

###############################   Mutation and Crossover Functions   ###########

def Mutation(index):
    formula = pop_df_new.iloc[index]['Formula']
    subformula = pop_df_new.iloc[index]['Subformula']
    signal = pop_df_new.iloc[index]['Signal']
    print(type(formula),formula,subformula,signal)
    # alter temporal operators
    if isinstance(formula, stlcg.Always):
        # change to eventually
        X = GP_opt('eventually', signal, subformula, input1=x1_reg_exp,input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        phi = stlcg.Eventually(subformula, interval=[int(X[0]), int(X[1])])
        param = [int(X[0]), int(X[1])]
    elif isinstance(formula, stlcg.Eventually):
        X = GP_opt('always', signal, subformula, input1=x1_reg_exp,
                   input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        # change to Always
        phi = stlcg.Always(subformula, interval=[int(X[0]), int(X[1])])
        param = [int(X[0]), int(X[1])]
    elif isinstance(formula, stlcg.Until):
        X = GP_opt('until', signal, subformula[1],subformula[0], input1=x1_reg_exp,
                   input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        # flip until
        phi = stlcg.Until(subformula[1],subformula[0], interval=[int(X[0]), int(X[1])])
        param = [int(X[0]), int(X[1])]
    elif isinstance(formula, stlcg.And):
        # change to or
        phi = stlcg.Or(subformula[0], subformula[1])
    elif isinstance(formula, stlcg.Or):
        # change to and
        phi = stlcg.And(subformula[0], subformula[1])
    elif isinstance(formula, stlcg.LessThan):
        # change to >
        X = GP_opt('greaterthan', signal, input1=x1_reg_exp,
                   input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        phi = stlcg.GreaterThan(subformula,X[0])
        param = [X[0]]
    elif isinstance(formula, stlcg.GreaterThan):
        # change to <
        X = GP_opt('lessthan', signal, input1=x1_reg_exp, input2=x2_reg_exp,
                   input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        
        phi = stlcg.LessThan(subformula,X[0])
        param = [X[0]]
        
    return phi, subformula, signal, param


def Crossover(index1,index2):
    formula1 = pop_df_new.iloc[index1]['Formula']
    formula2 = pop_df_new.iloc[index2]['Formula']
    subformula1 = pop_df_new.iloc[index1]['Subformula']
    subformula2 = pop_df_new.iloc[index2]['Subformula']
    
    print(type(formula),formula,subformula,signal)
    
    if isinstance(formula1, stlcg.And) and isinstance(formula2, stlcg.And):
        # flip subformula
        phi1 = stlcg.And(subformula1[0], subformula2[1])
        phi2 = stlcg.And(subformula2[0], subformula1[1])
    elif isinstance(formula1, stlcg.Or) and isinstance(formula2, stlcg.Or):
        # flip subformula
        phi1 = stlcg.Or(subformula1[0], subformula2[1])
        phi2 = stlcg.Or(subformula2[0], subformula1[1])
    return phi1,phi2,subformula1[0],subformula2[1],subformula2[0],subformula1[1]
    


for i in i in range(11, 51):
    if random.random() < 0.5:
        num = random.sample(range(0, 25), 1)
        phi, subformula, signal, param = Mutation(num)
    else:
        continue
        # crossover

