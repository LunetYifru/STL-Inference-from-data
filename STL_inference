import random
import statistics
from cmath import exp, inf
from random import sample

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import torch
from scipy.stats import norm

import stlcg
import GPyOptPars
from GPyOptPars import GP_opt


###################    Import Data    ##############################
x1_reg = pd.read_excel(r'x1_reg.xlsx', header=None)
x2_reg = pd.read_excel(r'x2_reg.xlsx', header=None)
x1_anom = pd.read_excel(r'x1_anom.xlsx', header=None)
x2_anom = pd.read_excel(r'x2_anom.xlsx', header=None)

rng_x1_reg = (min(x1_reg.min()), max(x1_reg.max()))
rng_x2_reg = (min(x2_reg.min()), max(x2_reg.max()))
rng_x1_anom = (min(x1_anom.min()), max(x1_anom.max()))
rng_x2_anom = (min(x2_anom.min()), max(x2_anom.max()))


rng = [rng_x1_reg, rng_x2_reg, rng_x1_anom, rng_x2_anom, len(x1_reg)]

x1_reg_exp = []
x2_reg_exp = []
x1_anom_exp = []
x2_anom_exp = []

for i in range(len(x1_reg.columns)):
    x1 = torch.tensor(x1_reg.iloc[:, i])
    x1 = x1.reshape(x1.shape[0], 1, 1)
    x_exp = stlcg.Expression('x1', x1)
    x1_reg_exp.append(x_exp)

    x2 = torch.tensor(x2_reg.iloc[:, i])
    x2 = x2.reshape(x2.shape[0], 1, 1)
    x_exp = stlcg.Expression('x2', x2)
    x2_reg_exp.append(x_exp)

    x1_ano = torch.tensor(x1_anom.iloc[:, i])
    x1_ano = x1_ano.reshape(x1_anom.shape[0], 1, 1)
    x_exp = stlcg.Expression('x1', x1_ano)
    x1_anom_exp.append(x_exp)

    x2_ano = torch.tensor(x2_anom.iloc[:, i])
    x2_ano = x2_ano.reshape(x2_ano.shape[0], 1, 1)
    x_exp = stlcg.Expression('x2', x2_ano)
    x2_anom_exp.append(x_exp)


###########  Random initialization of primary population and GP_opt to update parameters  ##########

pop_df = pd.DataFrame()

population = {}
X = GP_opt('lessthan', 'x1', input1=x1_reg_exp, input2=x2_reg_exp,
           input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_1'] = x1_reg_exp[0] < X[0]
X = GP_opt('greaterthan', 'x1', input1=x1_reg_exp, input2=x2_reg_exp,
           input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_2'] = x1_reg_exp[0] > X[0]
X = GP_opt('lessthan', 'x2', input1=x1_reg_exp, input2=x2_reg_exp,
           input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_3'] = x2_reg_exp[0] < X[0]
X = GP_opt('greaterthan', 'x2', input1=x1_reg_exp, input2=x2_reg_exp,
           input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_4'] = x2_reg_exp[0] > X[0]

X = GP_opt('always', 'x1', population['phi_1'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_5'] = stlcg.Always(
    population['phi_1'], interval=[int(X[0]), int(X[1])])
X = GP_opt('always', 'x1', population['phi_2'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_6'] = stlcg.Always(
    population['phi_2'], interval=[int(X[0]), int(X[1])])
X = GP_opt('always', 'x2', population['phi_3'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_7'] = stlcg.Always(
    population['phi_3'], interval=[int(X[0]), int(X[1])])
X = GP_opt('always', 'x2', population['phi_4'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_8'] = stlcg.Always(
    population['phi_4'], interval=[int(X[0]), int(X[1])])

X = GP_opt('eventually', 'x1', population['phi_1'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_9'] = stlcg.Eventually(
    population['phi_1'], interval=[int(X[0]), int(X[1])])
X = GP_opt('eventually', 'x1', population['phi_2'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_10'] = stlcg.Eventually(
    population['phi_2'], interval=[int(X[0]), int(X[1])])
X = GP_opt('eventually', 'x2', population['phi_3'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_11'] = stlcg.Eventually(
    population['phi_3'], interval=[int(X[0]), int(X[1])])
X = GP_opt('eventually', 'x2', population['phi_4'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_12'] = stlcg.Eventually(
    population['phi_4'], interval=[int(X[0]), int(X[1])])

X = GP_opt('always', 'x1', population['phi_9'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_13'] = stlcg.Always(
    population['phi_9'], interval=[int(X[0]), int(X[1])])
X = GP_opt('always', 'x1', population['phi_10'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_14'] = stlcg.Always(
    population['phi_10'], interval=[int(X[0]), int(X[1])])
X = GP_opt('always', 'x2', population['phi_11'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_15'] = stlcg.Always(
    population['phi_11'], interval=[int(X[0]), int(X[1])])
X = GP_opt('always', 'x2', population['phi_12'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_16'] = stlcg.Always(
    population['phi_12'], interval=[int(X[0]), int(X[1])])

X = GP_opt('eventually', 'x1', population['phi_5'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_17'] = stlcg.Eventually(
    population['phi_5'], interval=[int(X[0]), int(X[1])])
X = GP_opt('eventually', 'x1', population['phi_6'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_18'] = stlcg.Eventually(
    population['phi_6'], interval=[int(X[0]), int(X[1])])
X = GP_opt('eventually', 'x2', population['phi_7'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_19'] = stlcg.Eventually(
    population['phi_7'], interval=[int(X[0]), int(X[1])])
X = GP_opt('eventually', 'x2', population['phi_8'], input1=x1_reg_exp,
           input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
population['phi_20'] = stlcg.Eventually(
    population['phi_8'], interval=[int(X[0]), int(X[1])])


pop_df['Name'] = population.keys()
pop_df['Formula'] = population.values()
pop_df['Subformula'] = [x1_reg_exp[0], x1_reg_exp[0], x2_reg_exp[0], x2_reg_exp[0], population['phi_1'], population['phi_2'], population['phi_3'], population['phi_4'], population['phi_1'], population['phi_2'],
                        population['phi_3'], population['phi_4'], population['phi_5'], population['phi_6'], population['phi_7'], population['phi_8'], population['phi_9'], population['phi_10'], population['phi_11'], population['phi_12']]
# pop_df['Signal'] = [x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp,
# x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, x1_reg_exp, ]
pop_df['Signal'] = ['x', 'x', 'y', 'y', 'x', 'x', 'y', 'y',
                    'x', 'x', 'y', 'y', 'x', 'x', 'y', 'y', 'x', 'x', 'y', 'y']
print(pop_df.head(20))

######################### random initialization of non-primary formulae + GP_opt  #######################
pop_ext = {}
for i in range(11, 51):
    rand = random.randint(2, 4)
    num = random.sample(range(0, len(pop_df)), 2)

    subformula = [pop_df.iloc[num[0]]['Formula'],
                  pop_df.iloc[num[1]]['Formula']]

    if rand == 1:
        while pop_df.iloc[num[0]]['Signal'] == pop_df.iloc[num[1]]['Signal']:
            num = random.sample(range(0, len(pop_df)+1), 2)
            subformula = [pop_df.iloc[num[0]]['Formula'],
                          pop_df.iloc[num[1]]['Formula']]
        X = GP_opt('until', 'both', subformula[0], subformula[1], input1=x1_reg_exp,
                   input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        pop_ext['phi_' +
                str(i)] = stlcg.Until(subformula[0], subformula[1], interval=[int(X[1]), int(X[1])])

        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]], 'Signal': [pop_df.iloc[num[0]]['Signal'], pop_df.iloc[num[1]]['Signal']]}, ignore_index=True)
    elif rand == 2:
        pop_ext['phi_' +
                str(i)] = stlcg.And(subformula[0], subformula[1])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]], 'Signal': [pop_df.iloc[num[0]]['Signal'], pop_df.iloc[num[1]]['Signal']]}, ignore_index=True)
    elif rand == 3:
        pop_ext['phi_' +
                str(i)] = stlcg.Or(subformula[0], subformula[1])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]], 'Signal': [pop_df.iloc[num[0]]['Signal'], pop_df.iloc[num[1]]['Signal']]}, ignore_index=True)
    elif rand == 4:
        pop_ext['phi_' +
                str(i)] = stlcg.Negation(subformula[0])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0]], 'Signal': [pop_df.iloc[num[0]]['Signal']]}, ignore_index=True)
population = {**population, **pop_ext}

print(pop_df.head(30))
print('Length of DF ---', len(pop_df))


##############################     parameters for formula           ##################
import copy
def compute_rob(formula, signal):
    rob_all = np.empty(0)
    print('fromula: ', formula, 'signal: ', signal, 'type: ', type(signal))
    print('sig1:', signal)
    if isinstance(signal, str):
        signal = [signal]

    for k in range(len(x1_reg_exp)):
        copy_sig = copy.deepcopy(signal)
        print('sig2:', signal)
        for i in range(len(copy_sig)):
            print('copy sig:', copy_sig)
            print('signal is:', signal)
            if len(copy_sig[i]) == 1:
                print('len is 1')
                if copy_sig[i] == 'x':
                    print('len is 1, it is x', i)
                    print('signal is:', signal)
                    copy_sig[i] = x1_reg_exp[k]
                    print('signal is:', signal, 'copy is', copy_sig)
                else:
                    print('len is 1, it is y', i)
                    print(
                        'Now: ', copy_sig[i], '--- Change to: ', type(x2_reg_exp[k]))
                    print('signal is:', signal)
                    copy_sig[i] = x2_reg_exp[k]
                    print('Copy sig nowwww - ', copy_sig)
            else:
                for j in range(len(copy_sig[i])):
                    print('copy sig here is : ', copy_sig)
                    print('len is not 1', i, j)
                    print(copy_sig[i][j], '----i is: ', i, '----j is: ', j)
                    print('signal is:', signal)
                    if copy_sig[i][j] == 'x':
                        copy_sig[i][j] = x1_reg_exp[k]
                    else:
                        print('len is not 1, it is y', i, j)
                        copy_sig[i][j] = x2_reg_exp[k]
                        print('signal is:', signal)

        for i in range(len(copy_sig)):
            if not(isinstance(copy_sig[i],  stlcg.Expression)):
                copy_sig[i] = tuple(copy_sig[i])

        copy_sig = tuple(copy_sig)

        try:
            rob = min(formula.robustness(copy_sig[0]))
        except:
            rob = min(formula.robustness(copy_sig))
        rob_all = np.append(rob_all, rob)

    print('Tuple signal: ', copy_sig)

    return np.average(rob_all)


def formula_size(formula):
    string = str(formula)
    ops = '<>♢◻∧∨¬U'
    count = 0
    for i in string:
        if i in ops:
            count += 1
    return count


def fitness_func(robustness, size):
    if size < 3:
        Fitness_score = robustness
    else:
        # decrease robustness by (size-2)X10 % for sizes greater than 2
        Fitness_score = robustness*(1-(size-2)/10)
    return Fitness_score

###################      Compute robustness, size, and fitness       ###########################


pop_rob = []
pop_size = []
pop_fit = []
for i in range(len(pop_df)):
    formula = pop_df.iloc[i]['Formula']
    subformula = pop_df.iloc[i]['Subformula']
    signal = pop_df.iloc[i]['Signal']

    pop_rob.append(compute_rob(formula, signal))
    print('Average robustness: ', pop_rob[-1])

    pop_size.append(formula_size(formula))
    print('Size: ', formula_size(formula))

    pop_fit.append(fitness_func(pop_rob[-1], pop_size[-1]))
    print('Fitness Score: ', pop_fit[-1])


####################          Update dataframe        ##########################

pop_df['Robustness'] = pop_rob
pop_df['Size'] = pop_size
pop_df['Fitness'] = pop_fit

#####################      Rearrange  population with descending order of fitness  ############

pop_df['Rank'] = pop_df['Fitness'].rank(ascending=0)
pop_df = pop_df.set_index('Rank')
pop_df = pop_df.sort_index()
pop_df.reset_index(inplace=True)
print(pop_df.head())

####################       New generation parents (Top 25)   ####################

pop_df_new = pop_df.head(25)
print(pop_df_new.columns)

###############################   Mutation and Crossover Functions   ###########


def Mutation(index):
    formula = pop_df_new.iloc[index]['Formula']
    subformula = pop_df_new.iloc[index]['Subformula']
    signal = pop_df_new.iloc[index]['Signal']
    # alter temporal operators
    if isinstance(formula, stlcg.Always):
        # change to eventually
        X = GP_opt('always', signal, subformula[0], input1=x1_reg_exp,
                   input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        phi = stlcg.Eventually(subformula[1], interval=[int(X[0]), int(X[1])])
    elif isinstance(formula, stlcg.Eventually, interval=[]):
        X = GP_opt('eventually', signal, subformula[0], input1=x1_reg_exp,
                   input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        # change to Always
        phi = stlcg.Always(subformula[0], interval=[int(X[0]), int(X[1])])
    elif isinstance(formula, stlcg.And):
        # change to or
        phi = stlcg.Or(subformula[1], subformula[2])
    elif isinstance(formula, stlcg.Or):
        # change to and
        phi = stlcg.And(subformula[1], subformula[2])
    elif isinstance(formula, stlcg.LessThan):
        # change to >
        X = GP_opt('greaterthan', signal, input1=x1_reg_exp,
                   input2=x2_reg_exp, input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        phi = subformula[0] > X[0]
    elif isinstance(formula, stlcg.GreaterThan):
        # change to <
        X = GP_opt('lessthan', signal, input1=x1_reg_exp, input2=x2_reg_exp,
                   input3=x1_anom_exp, input4=x2_anom_exp, rng=rng)
        phi = subformula[0] < X[0]
    # elif isinstance(formula, stlcg.Until):
    #     # change to and
    #     phi = stlcg.And(subformula[0], subformula[1])
    return phi


def Crossover(index):
    formula = pop_df_new.iloc[index]['Formula']
    subformula = pop_df_new.iloc[index]['Subformula']
    signal = pop_df_new.iloc[index]['Signal']


for i in pop_df_new['Formula']:
    if random.random() < 0.1:
        # Mutation

        pass
    else:
        continue
        # crossover

        # def Crossover(formula1, formula2, subformula1, sunformula2):
        # if isinstance(formula1, stlcg.And) and isinstance(formula1, stlcg.Or):
        #pop_ext['phi_' + str(i)] = stlcg.Negation(subformula[0])


# x = pop_df.iloc[2]['Subformula']
