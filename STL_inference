import random
import statistics
from cmath import exp, inf
from random import sample

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import torch
from scipy.stats import norm

import stlcg
import GPyOptPars
from GPyOptPars import GP_opt

x_og = np.linspace(-1, 1, 1000)
mean = statistics.mean(x_og)
sd = statistics.stdev(x_og)
x_og = norm.pdf(x_og, mean, sd)
x = torch.tensor(x_og)
# x = x.reshape(x.shape[0],1,1)
x = x.reshape(1, x.shape[0], 1)


x_exp = stlcg.Expression('x', x)


pop_df = pd.DataFrame()
t1 = 10
t2 = 20
c1 = 10
c2 = 20
for_1 = stlcg.LessThan(lhs='x_exp', val=c1)
for_2 = stlcg.GreaterThan(lhs='x_exp', val=c2)


##########################    Random initialization of population    ########################
population = {}
population['phi_1'] = for_1
population['phi_2'] = for_2
population['phi_3'] = stlcg.Always(
    list(population.values())[0], interval=[t1, t2])
population['phi_4'] = stlcg.Always(
    list(population.values())[1], interval=[t1, t2])
population['phi_5'] = stlcg.Eventually(
    list(population.values())[0], interval=[t1, t2])
population['phi_6'] = stlcg.Eventually(
    list(population.values())[1], interval=[t1, t2])
population['phi_7'] = stlcg.Always(
    list(population.values())[4], interval=[t1, t2])
population['phi_8'] = stlcg.Always(
    list(population.values())[5], interval=[t1, t2])
population['phi_9'] = stlcg.Eventually(
    list(population.values())[2], interval=[t1, t2])
population['phi_10'] = stlcg.Eventually(
    list(population.values())[3], interval=[t1, t2])

pop_df['Name'] = population.keys()
pop_df['Formula'] = population.values()
pop_df['Subformula'] = [None, None, list(population.values())[0], list(population.values())[1], list(population.values())[0], list(
    population.values())[1], list(population.values())[2], list(population.values())[3], list(population.values())[4], list(population.values())[5]]


pop_ext = {}
for i in range(11, 51):
    rand = random.randint(1, 4)
    subformula = random.sample(list(population.values()), 2)

    def always_pars(t1, t2):
        x = x.reshape(1, 2)
        t1 = int(x[:, 1])
        t2 = int(x[:, 2])
        if t1 < t2:
            phi = stlcg.Always(
                subformula[0], interval=[t1, t2])
            rob = float(min(phi.robustness(x_exp)))
            A = (1/(rob+exp(-10*rob)))-exp(-rob)
        else:
            A = -10
        return -A

    if rand == 1:
        pars = GP_opt(subformula[0], subformula[1], x_exp, x_exp)

        pop_ext['phi_' +
                str(i)] = stlcg.Until(subformula[0], subformula[1], interval=[t1, t2])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]]}, ignore_index=True)
    elif rand == 2:
        pop_ext['phi_' +
                str(i)] = stlcg.And(subformula[0], subformula[1])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]]}, ignore_index=True)
    elif rand == 3:
        pop_ext['phi_' +
                str(i)] = stlcg.Or(subformula[0], subformula[1])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0], subformula[1]]}, ignore_index=True)
    elif rand == 4:
        pop_ext['phi_' +
                str(i)] = stlcg.Negation(subformula[0])
        pop_df = pop_df.append({'Name': 'phi_' + str(i),
                                'Formula': pop_ext['phi_' +
                                                   str(i)], 'Subformula': [subformula[0]]}, ignore_index=True)
population = {**population, **pop_ext}
print('Length of DF ---', len(pop_df))

print(pop_df.head(15))
###############################     GPUCB to update parameters      ####################


##############################     parameters for formula           ##################
def compute_rob(formula):
    try:
        rob = min(formula.robustness(x_exp))

    except:
        rob = min(formula.robustness((x_exp, x_exp)))
    # print(rob)
    return rob


def formula_size(formula):
    string = str(formula)
    ops = '<>♢◻∧∨¬U'
    count = 0
    for i in string:
        if i in ops:
            count += 1
    return count


def fitness_func(robustness, size):
    Fitness_score = robustness - size
    return Fitness_score


###################      Compute robustness, size, and fitness       ###########################

pop_rob = []
pop_size = []
pop_fit = []
for i in pop_df['Formula']:
    print(i)
    pop_rob.append(compute_rob(i))
    print('Robustness: ', compute_rob(i))
    pop_size.append(formula_size(i))
    print('Size: ', formula_size(i))
    pop_fit.append(fitness_func(pop_rob[-1], pop_size[-1]))


####################          Update dataframe        ##########################

pop_df['Robustness'] = pop_rob
pop_df['Size'] = pop_size
pop_df['Fitness'] = pop_fit

#####################      Rearrange  population with descending order of fitness  ############

pop_df['Rank'] = pop_df['Fitness'].rank(ascending=0)
pop_df = pop_df.set_index('Rank')
pop_df = pop_df.sort_index()
pop_df.reset_index(inplace=True)
print(pop_df.head())

####################       New generation parents (Top 25)   ####################

pop_df_new = pop_df.head(25)
print(pop_df_new.columns)

###################################   Mutation and CrossOver (Remaining 25)   ################################

for i in range(26, 51):
    if random.random() < 0.1:
        # Mutation

        # def Mutation(formula, subformula):
        #     # alter temporal operators
        #     if isinstance(formula, stlcg.Always):
        #         # change to eventually
        #         phi = stlcg.Eventually(subformula[1])
        #         pass
        #     elif isinstance(formula, stlcg.Eventually,):
        #         phi = stlcg.Always(subformula[1])
        #         # change to Always
        #         pass
        #     # alter predicate sign
        #     elif isinstance(formula, stlcg.And):
        #         # change to greater than
        #         phi = stlcg.Or(subformula[1], subformula[2])
        #     elif isinstance(formula, stlcg.Or):
        #         # change to greater than
        #         phi = stlcg.And(subformula[1], subformula[2])
        #     return phi
        pass
    else:
        continue
        # crossover

        # def Crossover(formula1, formula2, subformula1, sunformula2):
        # if isinstance(formula1, stlcg.And) and isinstance(formula1, stlcg.Or):
        #pop_ext['phi_' + str(i)] = stlcg.Negation(subformula[0])


# x = pop_df.iloc[2]['Subformula']
