from cmath import inf
import torch
from math import exp
import stlcg
from random import seed
import GPyOpt
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt
import STL_inference
from STL_inference import fix_sig

x_og = np.linspace(-1, 1, 1000)


def GP_opt(*subfor, **inputs):
    def pars(x):
        t1 = 0
        t2 = inf
        if subfor[0].lower() == 'always':
            x = x.reshape(1, 2)
            t1 = int(x[:, 0])
            t2 = int(x[:, 1])
            phi = stlcg.Always(subfor[2], interval=[t1, t2])
        elif subfor[0].lower() == 'eventually':
            x = x.reshape(1, 2)
            t1 = int(x[:, 0])
            t2 = int(x[:, 1])
            phi = stlcg.Eventually(subfor[2], interval=[t1, t2])
        elif subfor[0].lower() == 'until':
            x = x.reshape(1, 2)
            t1 = int(x[:, 0])
            t2 = int(x[:, 1])
            phi = stlcg.Until(subfor[2], subfor[3], interval=[t1, t2])
        elif subfor[0].lower() == 'lessthan':
            c = torch.from_numpy(x)
            if subfor[1].lower() == 'x1':
                phi = inputs['input1'][0] < c
            else:
                phi = inputs['input2'][0] < c

        elif subfor[0].lower() == 'greaterthan':
            c = torch.from_numpy(x)

            if subfor[1].lower() == 'x1':
                phi = inputs['input1'][0] > c
            else:
                phi = inputs['input2'][0] > c

        rob_reg = np.empty(0)
        rob_anom = np.empty(0)
        
        print(phi)

        if t1 < t2:
            for i in range(len(inputs['input1'])):
                x_1_reg = inputs['input1'][i]
                x_2_reg = inputs['input2'][i]
                x_1_anom = inputs['input3'][i]
                x_2_anom = inputs['input4'][i]
                ip_2_reg = (x_1_reg, x_2_reg)
                ip_2_anom = (x_1_anom, x_2_anom)
                if subfor[0].lower() == 'lessthan' or subfor[0].lower() == 'greaterthan':
                    if subfor[1].lower() == 'x1':
                        rob_ = float(min(phi.robustness(x_1_reg)))
                        rob_reg = np.append(rob_reg, rob_)
                    elif subfor[1].lower() == 'x2':
                        rob_ = float(min(phi.robustness(x_2_reg)))
                        rob_reg = np.append(rob_reg, rob_)
                else:
                    try:
                        if subfor[0].lower() == 'always':
                            if subfor[1].lower() == 'x1':
                                # print('size of rob tensor is :',phi.robustness(x_1_reg)[t1:t2],t1,t2)
                                rob_ = float(min(phi.robustness(x_1_reg)[t1:t2]))
                                rob_reg = np.append(rob_reg, rob_)
                            else:
                                rob_ = float(min(phi.robustness(x_2_reg)[t1:t2]))
                                rob_reg = np.append(rob_reg, rob_)
                        elif subfor[0].lower() == 'eventually':
                            if subfor[1].lower() == 'x1':
                                rob_ = float(max(phi.robustness(x_1_reg)[t1:t2]))
                                rob_reg = np.append(rob_reg, rob_)
                            else:
                                rob_ = float(max(phi.robustness(x_2_reg)[t1:t2]))
                                rob_reg = np.append(rob_reg, rob_)
                        
                    except:
                        if subfor[0].lower() == 'always':
                                rob_ = float(min(phi.robustness(ip_2_reg)[t1:t2]))
                                rob_reg = np.append(rob_reg, rob_)
                        elif subfor[0].lower() == 'eventually':
                                rob_ = float(max(phi.robustness(ip_2_reg)[t1:t2]))
                                rob_reg = np.append(rob_reg, rob_)
                    
                    # print('Robustness : ',float(min(phi.robustness(ip_2_reg))))

            rob_reg_av = np.average(rob_reg)
            print('Robustness average', rob_reg_av)
            rob_anom_av = np.average(rob_anom)
            rob_reg_std = np.std(rob_reg)
            rob_anom_std = np.std(rob_anom)
            A = (1/(rob_reg_av+exp(-10*rob_reg_av)))-exp(-rob_reg_av)
        else:
            A = -100
            # print('t1 was greater than t2', A)
        return -A



    if subfor[0].lower() == 'lessthan' or subfor[0].lower() == 'greaterthan':
        if subfor[1].lower == 'x1':
            space = [{'name': 'c', 'type': 'continuous', 'domain': (
                0.5*inputs['rng'][0][0], 2*inputs['rng'][0][1])}]
        else:
            space = [{'name': 'c', 'type': 'continuous', 'domain': (
                0.5*inputs['rng'][1][0], 2*inputs['rng'][1][1])}]

    else:
        space = [{'name': 't1', 'type': 'continuous', 'domain': (
            0, inputs['rng'][4]-1)}, {'name': 't2', 'type': 'continuous', 'domain': (1, inputs['rng'][4])}]

    # constraints = [{'name': 'constr_1', 'constraint': '-x[:,1] -.5 + abs(x[:,0]) - np.sqrt(1-x[:,0]**2)'},
    #    {'name': 'constr_2', 'constraint': 'x[:,1] +.5 - abs(x[:,0]) - np.sqrt(1-x[:,0]**2)'}]

    feasible_region = GPyOpt.Design_space(space=space)
    # Grid of points to make the plots
    grid = 400
    bounds = feasible_region.get_continuous_bounds()
    print(bounds)

    # X1 = np.linspace(bounds[0][0], bounds[1][0], grid)
    # --- CHOOSE the intial design

    seed(123456)
    initial_design = GPyOpt.experiment_design.initial_design(
        'random', feasible_region, 10)

    # print(initial_design)
    # --- CHOOSE the objective
    objective = GPyOpt.core.task.SingleObjective(pars)

    # --- CHOOSE the model type
    model = GPyOpt.models.GPModel(
        exact_feval=True, optimize_restarts=10, verbose=False)

    # --- CHOOSE the acquisition optimizer
    aquisition_optimizer = GPyOpt.optimization.AcquisitionOptimizer(
        feasible_region)

    # --- CHOOSE the type of acquisition
    acquisition = GPyOpt.acquisitions.AcquisitionEI(
        model, feasible_region, optimizer=aquisition_optimizer)

    # --- CHOOSE a collection method
    evaluator = GPyOpt.core.evaluators.Sequential(acquisition)

    # BO object
    bo = GPyOpt.methods.ModularBayesianOptimization(
        model, feasible_region, objective, acquisition, evaluator, initial_design)

    # --- Stop conditions
    max_time = None
    max_iter = 1
    tolerance = 1e-8     # distance between two consecutive observations

    # Run the optimization
    bo.run_optimization(max_iter=max_iter, max_time=max_time,
                        eps=tolerance, verbosity=True)

    # bo.plot_acquisition()
    # bo.plot_convergence()

    # Best found value
    return bo.x_opt


