from cmath import inf
import torch
from math import exp
import stlcg
from random import seed
import GPyOpt
import numpy as np
import matplotlib.pyplot as plt
import copy


def GP_opt(*subfor, **inputs):
    def pars(x):
        t1 = 0
        t2 = inf
        if subfor[0].lower() == 'always':
            x = x.reshape(1, 2)
            t1 = int(x[:, 0])
            t2 = int(x[:, 1])
            phi = stlcg.Always(subfor[2], interval=[t1, t2])
        elif subfor[0].lower() == 'eventually':
            x = x.reshape(1, 2)
            t1 = int(x[:, 0])
            t2 = int(x[:, 1])
            phi = stlcg.Eventually(subfor[2], interval=[t1, t2])
#        elif subfor[0].lower() == 'until':
#            x = x.reshape(1, 2)
#            t1 = int(x[:, 0])
#            t2 = int(x[:, 1])
#            phi = stlcg.Until(subfor[2], subfor[3], interval=[t1, t2])
            
        elif subfor[0].lower() == 'lessthan':
            c = torch.from_numpy(x)
            if subfor[1].lower() == 'x1':
                phi = inputs['input1'][0] < c
            else:
                phi = inputs['input2'][0] < c

        elif subfor[0].lower() == 'greaterthan':
            c = torch.from_numpy(x)
            if subfor[1].lower() == 'x1':
                phi = inputs['input1'][0] > c
            else:
                phi = inputs['input2'][0] > c

        rob_reg_all = np.empty(0)
        rob_anom_all = np.empty(0)
        
        
        
        def fix_IP_reg(signal,l):  
            if isinstance(signal, str):
                signal = [signal]
            
            copy_sig = copy.deepcopy(signal)      
            copy_sig_reg = tuple(inputs['input1'][l] if not isinstance(j,list) and j == 'x' else inputs['input2'][l] if not isinstance(j,list) and j == 'y'
                        else(tuple(inputs['input1'][l] if not isinstance(k,list) and k == 'x' else inputs['input2'][l] if not isinstance(k,list) and k == 'y'
                            else (tuple(tuple(tuple(tuple(tuple(tuple(tuple(tuple(g) if not isinstance(g,list) else inputs['input1'][l] if g == 'x' else inputs['input2'][l] for g in n)
                                if isinstance(n,list) else inputs['input1'][l] if n == 'x' else inputs['input2'][l] for n in v)
                                    if isinstance(v,list) else inputs['input1'][l] if v == 'x' else inputs['input2'][l] for v in w)
                                        if isinstance(w,list)  else inputs['input1'][l] if w == 'x' else inputs['input2'][l] for w in s)
                                            if isinstance(s,list)  else inputs['input1'][l] if s == 'x' else inputs['input2'][l] for s in z)
                                                if isinstance(z,list)  else inputs['input1'][l] if z == 'x' else inputs['input2'][l] for z in i)
                                                    if isinstance(i,list)  else inputs['input1'][l] if i == 'x' else inputs['input2'][l] for i in k)) for k in j)) for j in copy_sig)
            return copy_sig_reg
        
        def fix_IP_anom(signal,l):  
            if isinstance(signal, str):
                signal = [signal]
            
            copy_sig = copy.deepcopy(signal)      
            copy_sig_anom = tuple(inputs['input3'][l] if not isinstance(j,list) and j == 'x' else inputs['input4'][l] if not isinstance(j,list) and j == 'y'
                        else(tuple(inputs['input3'][l] if not isinstance(k,list) and k == 'x' else inputs['input4'][l] if not isinstance(k,list) and k == 'y'
                            else (tuple(tuple(tuple(tuple(tuple(tuple(tuple(tuple(g) if not isinstance(g,list) else inputs['input3'][l] if g == 'x' else inputs['input4'][l] for g in n)
                                if isinstance(n,list) else inputs['input3'][l] if n == 'x' else inputs['input4'][l] for n in v)
                                    if isinstance(v,list) else inputs['input3'][l] if v == 'x' else inputs['input4'][l] for v in w)
                                        if isinstance(w,list)  else inputs['input3'][l] if w == 'x' else inputs['input4'][l] for w in s)
                                            if isinstance(s,list)  else inputs['input3'][l] if s == 'x' else inputs['input4'][l] for s in z)
                                                if isinstance(z,list)  else inputs['input3'][l] if z == 'x' else inputs['input4'][l] for z in i)
                                                    if isinstance(i,list)  else inputs['input3'][l] if i == 'x' else inputs['input4'][l] for i in k)) for k in j)) for j in copy_sig)
            return copy_sig_anom
        
#        print('Phi:', phi)
        
        if t1 < t2:
            for i in range(len(inputs['input1'])):
                signal_reg = fix_IP_reg(subfor[1],i)
                signal_anom = fix_IP_anom(subfor[1],i)
                try:
                    if isinstance(phi,stlcg.Always):
                        rob_reg = float(min(phi.robustness(signal_reg[0])[t1:t2]))
                        rob_anom = float(min(phi.robustness(signal_reg[0])[t1:t2]))
                    elif isinstance(phi,stlcg.Eventually):
                        rob_reg = float(max(phi.robustness(signal_reg[0])[t1:t2]))
                        rob_anom = float(max(phi.robustness(signal_anom[0])[t1:t2]))
                    else:
                        rob_reg = min(phi.robustness(signal_reg[0]))
                        rob_anom = min(phi.robustness(signal_anom[0]))
                except:
                    if isinstance(phi,stlcg.Always):
                        rob_reg = float(min(phi.robustness(signal_reg)[t1:t2]))
                        rob_anom = float(min(phi.robustness(signal_anom)[t1:t2]))

                    elif isinstance(phi,stlcg.Eventually):
                        rob_reg = float(max(phi.robustness(signal_reg)[t1:t2]))
                        rob_anom = float(max(phi.robustness(signal_anom)[t1:t2]))

                    else:
                        rob_reg = min(phi.robustness(signal_reg))
                        rob_anom = min(phi.robustness(signal_anom))
                
                rob_reg_all = np.append(rob_reg_all, rob_reg)
                rob_anom_all = np.append(rob_anom_all, rob_anom)
                    
                    # print('Robustness : ',float(min(phi.robustness(ip_2_reg))))

            rob_reg_av = np.average(rob_reg_all)
            rob_anom_av = np.average(rob_anom_all)
#            rob_reg_std = np.std(rob_reg_all)
#            rob_anom_std = np.std(rob_anom_all)
            
            # A = (1/(rob_reg_av+exp(-10*rob_reg_av)))-exp(-rob_reg_av)
            gap = np.absolute(rob_reg_av - rob_anom_av)
        else:
            gap = -100
            # print('t1 was greater than t2', A)
        return -gap



    if subfor[0].lower() == 'lessthan' or subfor[0].lower() == 'greaterthan':
        if subfor[1].lower == 'x1':
            space = [{'name': 'c', 'type': 'continuous', 'domain': (
                0.5*inputs['rng'][0][0], inputs['rng'][0][1])}]
        else:
            space = [{'name': 'c', 'type': 'continuous', 'domain': (
                0.5*inputs['rng'][1][0], inputs['rng'][1][1])}]

    else:
        space = [{'name': 't1', 'type': 'continuous', 'domain': (
            0, inputs['rng'][4]-1)}, {'name': 't2', 'type': 'continuous', 'domain': (1, inputs['rng'][4])}]

    # constraints = [{'name': 'constr_1', 'constraint': '-x[:,1] -.5 + abs(x[:,0]) - np.sqrt(1-x[:,0]**2)'},
    #    {'name': 'constr_2', 'constraint': 'x[:,1] +.5 - abs(x[:,0]) - np.sqrt(1-x[:,0]**2)'}]

    feasible_region = GPyOpt.Design_space(space=space)
    # Grid of points to make the plots
#    grid = 400
#    bounds = feasible_region.get_continuous_bounds()
#    print(bounds)

    # X1 = np.linspace(bounds[0][0], bounds[1][0], grid)
    # --- CHOOSE the intial design

#    seed(123456)
    initial_design = GPyOpt.experiment_design.initial_design(
        'random', feasible_region, 10)

    # print(initial_design)
    # --- CHOOSE the objective
    objective = GPyOpt.core.task.SingleObjective(pars)

    # --- CHOOSE the model type
    model = GPyOpt.models.GPModel(
        exact_feval=True, optimize_restarts=10, verbose=False)

    # --- CHOOSE the acquisition optimizer
    aquisition_optimizer = GPyOpt.optimization.AcquisitionOptimizer(
        feasible_region)

    # --- CHOOSE the type of acquisition
    acquisition = GPyOpt.acquisitions.AcquisitionEI(
        model, feasible_region, optimizer=aquisition_optimizer)

    # --- CHOOSE a collection method
    evaluator = GPyOpt.core.evaluators.Sequential(acquisition)

    # BO object
    bo = GPyOpt.methods.ModularBayesianOptimization(
        model, feasible_region, objective, acquisition, evaluator, initial_design)

    # --- Stop conditions
    max_time = None
    max_iter = 1
    tolerance = 1e-8     # distance between two consecutive observations

    # Run the optimization
    bo.run_optimization(max_iter=max_iter, max_time=max_time,
                        eps=tolerance, verbosity=True)

    # bo.plot_acquisition()
    # bo.plot_convergence()

    # Best found value
    return bo.x_opt

