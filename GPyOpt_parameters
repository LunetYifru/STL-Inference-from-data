from cmath import inf
import torch
from math import exp
import stlcg
from random import seed
import GPyOpt
import numpy as np
import matplotlib.pyplot as plt
import copy


def GP_opt(*subfor, **inputs):
    print('signal---',subfor[1])
    def pars(x):
        t1 = 0
        t2 = inf
        if subfor[0].lower() == 'always':
            x = x.reshape(1, 2)
            t1 = int(x[:, 0])
            t2 = int(x[:, 1])
            phi = stlcg.Always(subfor[2], interval=[t1, t2])
        elif subfor[0].lower() == 'eventually':
            x = x.reshape(1, 2)
            t1 = int(x[:, 0])
            t2 = int(x[:, 1])
            phi = stlcg.Eventually(subfor[2], interval=[t1, t2])
        elif subfor[0].lower() == 'until':
            x = x.reshape(1, 2)
            t1 = int(x[:, 0])
            t2 = int(x[:, 1])
            phi = stlcg.Until(subfor[2], subfor[3], interval=[t1, t2])
            
        elif subfor[0].lower() == 'lessthan':
            c = torch.from_numpy(x)
            if subfor[1].lower() == 'x1':
                phi = inputs['input1'][0] < c
            else:
                phi = inputs['input2'][0] < c

        elif subfor[0].lower() == 'greaterthan':
            c = torch.from_numpy(x)
            if subfor[1].lower() == 'x1':
                phi = inputs['input1'][0] > c
            else:
                phi = inputs['input2'][0] > c

        rob_reg = np.empty(0)
        rob_anom = np.empty(0)
        
        print('phi is----',phi)
        
        def fix_IP(signal,l):  
            if isinstance(signal, str):
                signal = [signal]
            
            copy_sig = copy.deepcopy(signal)      
            copy_sig = tuple(inputs['input1'][l] if not isinstance(j,list) and j == 'x' else inputs['input2'][l] if not isinstance(j,list) and j == 'y'
                        else(tuple(inputs['input1'][l] if not isinstance(k,list) and k == 'x' else inputs['input2'][l] if not isinstance(k,list) and k == 'y'
                            else (tuple(tuple(tuple(tuple(tuple(tuple(tuple(tuple(g) if not isinstance(g,list) else inputs['input1'][l] if g == 'x' else inputs['input2'][l] for g in n)
                                if isinstance(n,list) else inputs['input1'][l] if n == 'x' else inputs['input2'][l] for n in v)
                                    if isinstance(v,list) else inputs['input1'][l] if v == 'x' else inputs['input2'][l] for v in w)
                                        if isinstance(w,list)  else inputs['input1'][l] if w == 'x' else inputs['input2'][l] for w in s)
                                            if isinstance(s,list)  else inputs['input1'][l] if s == 'x' else inputs['input2'][l] for s in z)
                                                if isinstance(z,list)  else inputs['input1'][l] if z == 'x' else inputs['input2'][l] for z in i)
                                                    if isinstance(i,list)  else inputs['input1'][l] if i == 'x' else inputs['input2'][l] for i in k)) for k in j)) for j in copy_sig)
            return copy_sig

        if t1 < t2:
            for i in range(len(inputs['input1'])):
                signal = fix_IP(subfor[1],i)
                try:
                    if isinstance(phi,stlcg.Always):
                        rob_ = float(min(phi.robustness(signal[0])[t1:t2]))
                    elif isinstance(phi,stlcg.Eventually):
                        rob_ = float(max(phi.robustness(signal[0])[t1:t2]))
                    else:
                        rob_ = float(min(phi.robustness(signal[0]))) 
                except:
                    if isinstance(phi,stlcg.Always):
                        rob_ = float(min(phi.robustness(signal)[t1:t2]))
                    elif isinstance(phi,stlcg.Eventually):
                        rob_ = float(max(phi.robustness(signal)[t1:t2]))
                    else:
                        rob_ = float(min(phi.robustness(signal))) 
                
                rob_reg = np.append(rob_reg, rob_)
                    
                    # print('Robustness : ',float(min(phi.robustness(ip_2_reg))))

            rob_reg_av = np.average(rob_reg)
            print('Robustness average', rob_reg_av)
            rob_anom_av = np.average(rob_anom)
            rob_reg_std = np.std(rob_reg)
            rob_anom_std = np.std(rob_anom)
            
            A = (1/(rob_reg_av+exp(-10*rob_reg_av)))-exp(-rob_reg_av)
        else:
            A = -100
            # print('t1 was greater than t2', A)
        return -A



    if subfor[0].lower() == 'lessthan' or subfor[0].lower() == 'greaterthan':
        if subfor[1].lower == 'x1':
            space = [{'name': 'c', 'type': 'continuous', 'domain': (
                0.5*inputs['rng'][0][0], 2*inputs['rng'][0][1])}]
        else:
            space = [{'name': 'c', 'type': 'continuous', 'domain': (
                0.5*inputs['rng'][1][0], 2*inputs['rng'][1][1])}]

    else:
        space = [{'name': 't1', 'type': 'continuous', 'domain': (
            0, inputs['rng'][4]-1)}, {'name': 't2', 'type': 'continuous', 'domain': (1, inputs['rng'][4])}]

    # constraints = [{'name': 'constr_1', 'constraint': '-x[:,1] -.5 + abs(x[:,0]) - np.sqrt(1-x[:,0]**2)'},
    #    {'name': 'constr_2', 'constraint': 'x[:,1] +.5 - abs(x[:,0]) - np.sqrt(1-x[:,0]**2)'}]

    feasible_region = GPyOpt.Design_space(space=space)
    # Grid of points to make the plots
#    grid = 400
    bounds = feasible_region.get_continuous_bounds()
    print(bounds)

    # X1 = np.linspace(bounds[0][0], bounds[1][0], grid)
    # --- CHOOSE the intial design

    seed(123456)
    initial_design = GPyOpt.experiment_design.initial_design(
        'random', feasible_region, 10)

    # print(initial_design)
    # --- CHOOSE the objective
    objective = GPyOpt.core.task.SingleObjective(pars)

    # --- CHOOSE the model type
    model = GPyOpt.models.GPModel(
        exact_feval=True, optimize_restarts=10, verbose=False)

    # --- CHOOSE the acquisition optimizer
    aquisition_optimizer = GPyOpt.optimization.AcquisitionOptimizer(
        feasible_region)

    # --- CHOOSE the type of acquisition
    acquisition = GPyOpt.acquisitions.AcquisitionEI(
        model, feasible_region, optimizer=aquisition_optimizer)

    # --- CHOOSE a collection method
    evaluator = GPyOpt.core.evaluators.Sequential(acquisition)

    # BO object
    bo = GPyOpt.methods.ModularBayesianOptimization(
        model, feasible_region, objective, acquisition, evaluator, initial_design)

    # --- Stop conditions
    max_time = None
    max_iter = 1
    tolerance = 1e-8     # distance between two consecutive observations

    # Run the optimization
    bo.run_optimization(max_iter=max_iter, max_time=max_time,
                        eps=tolerance, verbosity=True)

    # bo.plot_acquisition()
    # bo.plot_convergence()

    # Best found value
    return bo.x_opt


